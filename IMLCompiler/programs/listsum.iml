program listSum()
global
fun sum(in copy l:[int]) returns var r:int
do
	if size l == 0 do
		r init := 0
	else
		r := head l + sum(tail tail tail l) // init should be allowed (and must actually be there)
	endif
endfun;
fun isPrime(in copy v:int) returns var b:bool
do
	b init := true
endfun;

var sum:int;
var primes:[int]
do
 	primes init := [x | x from -2 * 3 to 13 where isPrime(x)];
	sum init := sum(1 :: 3 :: 3 :: primes)
endprogram

/*
	// AST translated into something like this
	var $x1:int;
	var $$l1:[int];
	$x1 init := 0;
	$$l1 init := []
	
	while $x1 < 1000 do
		if isPrime(x)
			l1 := $x1 :: l1;
		else 
			skip;
		endif;
		$x1 := $x1 + 1 // oder $x1 := $x1 - 1 falls end > start  TODO NOT POSSIBLE BECAUSE ONLY KNOWN AT RUNTIME
	endwhile
	
	primes init := $$l1;
*/