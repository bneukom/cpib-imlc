program listSum()
global
fun sum(in copy l:[int]) returns var r:int
do
	if length l == 0 do
		r init := 0
	else
		r init := head l + sum(tail l) // init should be allowed (and must actually be there)
	endif
	
	if true do
		r init := 0
	else
		skip
	endif
	
	r := 0;
	
endfun;
fun isPrime(in copy v:int) returns var b:bool
do
	return true
	b init := true
endfun;

var sum:int;
var primes:[int];
var squaredPrimes:[int]
do
	primes init := {x | x from 2 to 1000 where isPrime(x)};
 	squaredPrimes init := {x * x | x from 2 to 1000 where isPrime(x)}
endprogram

/*
	// AST translated into something like this
	var $x1:int;
	var $$l1:[int];
	$x1 init := 2;
	$$l1 init := []
	
	while $x1 < 100 do
		if isPrime(x)
			l1 := $x1 :: l1;
		else 
			skip;
		endif;
		$x1 := $x1 + 1 // oder $x1 := $x1 - 1 falls end > start
	endwhile
	
	primes init := $$l1;
*/