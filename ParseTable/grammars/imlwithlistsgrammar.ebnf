program ::=
			PROGRAM IDENT progParamList
			[GLOBAL cpsDecl] DO cpsCmd ENDPROGRAM;
			
decl ::= stoDecl
		| funDecl
		| procDecl;
stoDecl ::= [CHANGEMODE] typedIdent;
funDecl ::= FUN IDENT paramList
			RETURNS stoDecl
			[GLOBAL globImps]
			[LOCAL cpsStoDecl] DO cpsCmd ENDFUN;
procDecl ::= PROC IDENT paramList
		[GLOBAL globImps]
		[LOCAL cpsStoDecl] DO cpsCmd ENDPROC;
globImps ::= globImp {COMMA globImp};
globImp ::= [FLOWMODE] [CHANGEMODE] IDENT;
cpsDecl ::= decl {SEMICOLON decl};
cpsStoDecl ::= stoDecl {SEMICOLON stoDecl};

  def typeparser: Parser[Type] = positioned(atomtype | listType)
  def atomtype: Parser[AtomType] = positioned("int" ^^^ { IntType } | "bool" ^^^ { BoolType })
  def listType: Parser[ListType] = positioned("[" ~ typeparser ~ "]" ^^ { case "[" ~ t ~ "]" => ListType(t) })
  
  def literal: Parser[Literal] = positioned(intLiteral | boolLiteral | listLiteral)
  def intLiteral: Parser[IntLiteral] = positioned("[0-9]+".r ^^ { x => IntLiteral(x.toInt) })
  def boolLiteral: Parser[BoolLiteral] = positioned(("true" | "false") ^^ { x => BoolLiteral(x.toBoolean) })
  def listLiteral: Parser[ListLiteral] = positioned("[" ~ repsep(expr, ",") ~ "]" ^^ { case "[" ~ l ~ "]" => ListLiteral(l) })

  
  
progParamList ::= LPAREN [progParam {COMMA progParam}] RPAREN;
progParam ::= [FLOWMODE] [CHANGEMODE] typedIdent;
paramList ::= LPAREN [param {COMMA param}] RPAREN;
param ::= [FLOWMODE] [MECHMODE] [CHANGEMODE] typedIdent;
typedIdent ::= IDENT COLON ATOMTYPE;

cmd ::= SKIP
	| expr BECOMES expr
	| IF expr THEN cpsCmd ELSE cpsCmd ENDIF
	| WHILE expr DO cpsCmd ENDWHILE
	| CALL IDENT exprList [globInits]
	| DEBUGIN expr
	| DEBUGOUT expr;
cpsCmd ::= cmd {SEMICOLON cmd};
globInits ::= INIT idents;
idents ::= IDENT {COMMA IDENT};

expr ::= term0 [CONCATOPR expr];
term0 ::= term1 {BOOLOPR term1};
term1 ::= term2 [RELOPR term2];
term2 ::= term3 {ADDOPR term3};
term3 ::= factor {MULTOPR factor};
factor ::= literal
		| IDENT [INIT | exprList]
		| monadicOpr factor
		| LPAREN expr RPAREN;
exprList ::= LPAREN [expr {COMMA expr}] RPAREN;
monadicOpr ::= NOT | ADDOPR | HEAD | TAIL | SIZE